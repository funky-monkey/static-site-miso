#!/usr/bin/env php
<?php

declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use Miso\Content\ContentLoader;
use Miso\Content\FrontMatterParser;
use Miso\Content\MarkdownConverter;
use Miso\Site\SiteConfig;
use Miso\Scaffold\Scaffolder;
use Miso\StaticSiteGenerator;
use Miso\Support\Filesystem;
use Twig\Environment;
use Twig\Loader\FilesystemLoader;

const VERSION = '0.1.0';
const COPYRIGHT = 'Â© Sidney de Koning, 2025';

$originalArguments = $argv;
array_shift($originalArguments);
$parsed = parseOptions($originalArguments);
$options = $parsed['options'];
$arguments = $parsed['arguments'];

$command = $arguments[0] ?? 'help';

switch ($command) {
    case 'build':
        runBuild(array_slice($arguments, 1), $options);
        break;
    case 'new':
        $path = $arguments[1] ?? '.';
        $force = isset($options['force']);
        runNew($path, $force);
        break;
    case 'run':
        runServe(array_slice($arguments, 1), $options);
        break;
    case 'version':
    case '--version':
    case '-V':
        echo 'Miso Static Site Generator ' . VERSION . ' ' . COPYRIGHT . PHP_EOL;
        exit(0);
    case 'help':
    case '--help':
    case '-h':
    default:
        echo <<<HELP
Miso Static Site Generator

Usage:
  miso build [options]
  miso new [path] [--force]
  miso run [options]
  miso help
  miso version

Options:
  --root=PATH        Project root (defaults to current working directory)
  --config=PATH      Path to config file (defaults to _config/site.yaml within root)
  --force            Overwrite existing files when scaffolding
  --host=HOST        Host for built-in server (default 127.0.0.1) [run]
  --port=PORT        Port for built-in server (default 8000) [run]
  --watch            Rebuild automatically when content/templates/css change [run]

HELP;
        echo COPYRIGHT . PHP_EOL;
        exit(0);
}

function runBuild(array $arguments, array $options): void
{
    [$generator] = initializeGenerator($options);

    try {
        $generator->build();
        echo "Build complete.\n";
        echo COPYRIGHT . PHP_EOL;
    } catch (\Throwable $e) {
        fwrite(STDERR, 'Build failed: ' . $e->getMessage() . PHP_EOL);
        exit(1);
    }
}

function runServe(array $arguments, array $options): void
{
    $watch = isset($options['watch']);

    [$generator, $config, $projectRoot] = initializeGenerator($options);

    try {
        $generator->build();
        echo "Build complete.\n";
    } catch (\Throwable $e) {
        fwrite(STDERR, 'Build failed: ' . $e->getMessage() . PHP_EOL);
        exit(1);
    }

    $host = $options['host'] ?? '127.0.0.1';
    $port = $options['port'] ?? '8000';

    $outputDir = $projectRoot . DIRECTORY_SEPARATOR . rtrim($config->path('output'), DIRECTORY_SEPARATOR);

    if (!is_dir($outputDir)) {
        fwrite(STDERR, "Output directory [$outputDir] not found after build.\n");
        exit(1);
    }

    $serverProcess = startPhpServer($outputDir, $host, $port);
    echo "Serving {$config->get('site.title', 'site')} at http://{$host}:{$port} (Ctrl+C to stop)\n";

    if (!$watch) {
        waitForProcess($serverProcess);
        return;
    }

    echo "Watching for changes...\n";
    $watchedExtensions = ['md', 'markdown', 'html', 'twig.html', 'css'];
    $watchedDirs = [
        $projectRoot . DIRECTORY_SEPARATOR . $config->path('content'),
        $projectRoot . DIRECTORY_SEPARATOR . $config->path('templates'),
        $projectRoot . DIRECTORY_SEPARATOR . 'css',
    ];

    $lastHashes = hashWatchedFiles($watchedDirs, $watchedExtensions);

    while (true) {
        if (!isProcessRunning($serverProcess)) {
            $serverProcess = startPhpServer($outputDir, $host, $port);
        }

        $hash = hashWatchedFiles($watchedDirs, $watchedExtensions);

        if ($hash !== $lastHashes) {
            $lastHashes = $hash;
            echo "[" . date('H:i:s') . "] Changes detected. Rebuilding...\n";
            try {
                $generator->build();
                echo "[" . date('H:i:s') . "] Build complete.\n";
            } catch (\Throwable $e) {
                fwrite(STDERR, "[" . date('H:i:s') . "] Build failed: " . $e->getMessage() . PHP_EOL);
            }
        }

        usleep(500000); // 0.5s
    }
}

function runNew(string $path, bool $force): void
{
    $path = $path === '.' ? getcwd() : $path;
    if ($path === false) {
        fwrite(STDERR, "Unable to determine target path.\n");
        exit(1);
    }

    $filesystem = new Filesystem();
    $projectRoot = dirname(__DIR__);
    $scaffolder = new Scaffolder($filesystem, $projectRoot . '/skeleton');

    try {
        $scaffolder->scaffold($path, $force);
        echo "Scaffold created at [$path].\n";
        echo "Next steps:\n";
        echo "  cd $path\n";
        echo "  composer install\n";
        echo "  miso build\n";
    } catch (\Throwable $e) {
        fwrite(STDERR, 'Scaffold failed: ' . $e->getMessage() . PHP_EOL);
        exit(1);
    }
}

/**
 * @param array<string, string> $options
 * @return array{0: StaticSiteGenerator, 1: SiteConfig, 2: string}
 */
function initializeGenerator(array $options): array
{
    $projectRoot = $options['root'] ?? getcwd();
    if ($projectRoot === false) {
        fwrite(STDERR, "Unable to determine project root.\n");
        exit(1);
    }

    $projectRoot = rtrim($projectRoot, DIRECTORY_SEPARATOR);

    $config = SiteConfig::load($projectRoot, $options['config'] ?? null);

    $templatesPath = $projectRoot . DIRECTORY_SEPARATOR . $config->path('templates');

    if (!is_dir($templatesPath)) {
        fwrite(STDERR, "Templates directory [$templatesPath] not found.\n");
        exit(1);
    }

    $loader = new FilesystemLoader([$templatesPath, __DIR__ . '/../templates']);
    $twig = new Environment($loader, [
        'cache' => false,
        'strict_variables' => false,
    ]);

    $generator = new StaticSiteGenerator(
        config: $config,
        loader: new ContentLoader(new FrontMatterParser(), new MarkdownConverter()),
        filesystem: new Filesystem(),
        twig: $twig,
        projectRoot: $projectRoot
    );

    return [$generator, $config, $projectRoot];
}

/**
 * @param array<int, string> $arguments
 * @return array{options: array<string, string>, arguments: array<int, string>}
 */
function parseOptions(array $arguments): array
{
    $options = [];
    $remaining = [];

    foreach ($arguments as $arg) {
        if (!str_starts_with($arg, '--')) {
            $remaining[] = $arg;
            continue;
        }

        $parts = explode('=', substr($arg, 2), 2);
        $key = $parts[0];
        $value = $parts[1] ?? 'true';
        $options[$key] = $value;
    }

    return ['options' => $options, 'arguments' => $remaining];
}

function startPhpServer(string $outputDir, string $host, string $port)
{
    $descriptorSpec = [
        0 => STDIN,
        1 => STDOUT,
        2 => STDERR,
    ];

    $process = proc_open(
        [
            PHP_BINARY,
            '-S', "{$host}:{$port}",
            '-t', $outputDir,
        ],
        $descriptorSpec,
        $pipes,
        $outputDir
    );

    if (!is_resource($process)) {
        fwrite(STDERR, "Failed to start PHP built-in server.\n");
        exit(1);
    }

    return $process;
}

function waitForProcess($process): void
{
    proc_close($process);
}

function isProcessRunning($process): bool
{
    if (!is_resource($process)) {
        return false;
    }

    $status = proc_get_status($process);
    return $status['running'] ?? false;
}

/**
 * @param array<int, string> $directories
 * @param array<int, string> $extensions
 * @return array<int, string>
 */
function hashWatchedFiles(array $directories, array $extensions): array
{
    $hashes = [];

    foreach ($directories as $directory) {
        if (!is_dir($directory)) {
            continue;
        }

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($directory, \FilesystemIterator::SKIP_DOTS)
        );

        /** @var \SplFileInfo $file */
        foreach ($iterator as $file) {
            if (!$file->isFile()) {
                continue;
            }

            $ext = strtolower($file->getExtension());
            if (!in_array($ext, $extensions, true)) {
                continue;
            }

            $hashes[] = $file->getPathname() . ':' . $file->getMTime();
        }
    }

    sort($hashes);

    return $hashes;
}
